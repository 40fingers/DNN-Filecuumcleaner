<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="btnCancel.Text" xml:space="preserve">
    <value>Cancel</value>
  </data>
  <data name="btnUpdate.Text" xml:space="preserve">
    <value>Update</value>
  </data>
  <data name="plId.Help" xml:space="preserve">
    <value>Internal Id of this import.</value>
  </data>
  <data name="plId.Text" xml:space="preserve">
    <value>Id</value>
  </data>
  <data name="plName.Help" xml:space="preserve">
    <value>Humanly recognisable identifier</value>
  </data>
  <data name="plName.Text" xml:space="preserve">
    <value>Name</value>
  </data>
  <data name="plIncludeSubFolders.Help" xml:space="preserve">
    <value>Also cleanup subfolders of the given path.</value>
  </data>
  <data name="plIncludeSubFolders.Text" xml:space="preserve">
    <value>Include Subfolders</value>
  </data>
  <data name="plPath.Help" xml:space="preserve">
    <value>Enter the path relative to the root you've chosen. E.g. use "Logs" for the host level logfiles folder if you chose "Host Root". The folder must exist and it is mandotory. Being able to clean all of your portal root would be too dangerous.</value>
  </data>
  <data name="plPath.Text" xml:space="preserve">
    <value>Path</value>
  </data>
  <data name="plMaxAgeDays.Help" xml:space="preserve">
    <value>Maximum allowed file age in days. Files older than this, will be deleted. Enter 0 to ignore this criterium.</value>
  </data>
  <data name="plMaxAgeDays.Text" xml:space="preserve">
    <value>Maximum Age (Days)</value>
  </data>
  <data name="plMaxBytes.Help" xml:space="preserve">
    <value>Maximum number of bytes allowed for a single file. Larger files will be deleted.. Enter 0 to ignore this criterium.</value>
  </data>
  <data name="plMaxBytes.Text" xml:space="preserve">
    <value>Maximum Size (Bytes)</value>
  </data>
  <data name="plRootPath.Help" xml:space="preserve">
    <value>Choose a root folder to use for the job.</value>
  </data>
  <data name="plRootPath.Text" xml:space="preserve">
    <value>Root Path</value>
  </data>
  <data name="RootPath.Host" xml:space="preserve">
    <value>Host Home Folder</value>
  </data>
  <data name="RootPath.Portal" xml:space="preserve">
    <value>{1} (PortalID {0})</value>
  </data>
  <data name="RootPath.Website" xml:space="preserve">
    <value>Website root</value>
  </data>
  <data name="IncludedExtensions.Required" xml:space="preserve">
    <value>You must specify which file extensions are to be deleted.</value>
  </data>
  <data name="InstructionsLabel.Text" xml:space="preserve">
    <value>User the form below to define your cleaning job. Please note that entering 0 as Maximum Size AND as Maximum Age, will result in no files being deleted.</value>
  </data>
  <data name="MaxAgeDays.Invalid" xml:space="preserve">
    <value>Please specify a positive whole number</value>
  </data>
  <data name="MaxBytes.Invalid" xml:space="preserve">
    <value>Please specify a positive whole number</value>
  </data>
  <data name="Path.Invalid" xml:space="preserve">
    <value>Path cannot contain ".." to move a directory up. For your safety.</value>
  </data>
  <data name="Path.Required" xml:space="preserve">
    <value>Please specify the path to clean</value>
  </data>
  <data name="plDeleteEmptyFolders.Help" xml:space="preserve">
    <value>Deletes cleaned folders when they're empty after cleaning.</value>
  </data>
  <data name="plDeleteEmptyFolders.Text" xml:space="preserve">
    <value>Delete empty folders</value>
  </data>
  <data name="plIncludedExtensions.Help" xml:space="preserve">
    <value>Enter a comma separated list of file extensions that are allowed to be removed. E.g.: "log,txt". Please note that the extension for a file named "2014-04-23.log.resources" is "resources"</value>
  </data>
  <data name="plIncludedExtensions.Text" xml:space="preserve">
    <value>Included Extensions</value>
  </data>
  <data name="plJobEnabled.Text" xml:space="preserve">
    <value>Job Enabled</value>
  </data>
  <data name="RequiredIndicatorLabel.Text" xml:space="preserve">
    <value>Required Field</value>
  </data>
</root>